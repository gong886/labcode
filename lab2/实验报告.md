## 1 小组成员及学号

### 组长：龚子超-2312005
### 组员：熊泽宇-2312015，吴红祥-2312558

## 2 填写各个基本练习中要求完成的报告内容

### 2.1 练习一
理解first-fit 连续物理内存分配算法（思考题）

first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合kern/mm/default_pmm.c中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。 请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

#### 2.1.1函数分析

default_init()

作用：初始化空闲链表 free_list，将空闲页总数 nr_free 设置为 0。

功能：始化空闲内存链表和计数器。


default_init_memmap(struct Page *base, size_t n)

作用：
遍历 base 到 base+n 的每个页，清除 flags 和 property，将引用计数置 0，设置首个页的 property = n 并标记 PG_property。更新 nr_free += n。将块插入空闲链表 free_list，保持按物理地址顺序。

功能:将一段物理内存初始化为可用，设置页面属性，并将首页加入空闲链表。


default_alloc_pages(size_t n)

作用：遍历 free_list 查找第一个 property >= n 的块。找到块，将前 n 页标记已占用，从链表中删除这部分页。如果剩余页数 > 0，则将多余部分插回链表，更新 nr_free -= n。如果未找到，返回 NULL。

功能：遍历空闲链表找到第一个满足大小需求的块。


default_free_pages(struct Page *base, size_t n)

作用：遍历释放页，将 flags 和引用计数清零，设置首页 property = n 并标记 PG_property，插入 free_list，保持按物理地址顺序。检查前后相邻块，如果连续则合并，然后更新 property，删除被合并的链表节点。更新 nr_free += n。

功能：释放连续 n 页物理内存，并尝试合并相邻空闲块。



#### 2.1.2物理内存分配过程

1.启动时 default_init() 配置数据结构并把所有可用内存块通过 default_init_memmap() 建立到空闲链表/块结构。

2.当需要连续 n 页时调用 default_alloc_pages(size_t n)扫描空闲链表找到第一个能满足的空闲块。从该空闲块切分出 n 页，更新空闲结构并返回。

3.当释放时 default_alloc_pages(size_t n) 将页标为 free，并与邻居合并、更新链表。



#### 2.1.3改进

1.可以采用分级空闲链表。

2.弃用线性遍历，采用二叉树或跳表。

3.延迟合并，只在有需要时重新合并空闲相邻块，减少因频繁合并产生的开销。



### 2.2 练习二
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？
#### 2.2.1 设计原理
Best Fit（最佳适应）算法是一种动态内存分配策略，其核心思想是：从所有空闲内存块中找出大小最接近请求大小的块进行分配。因此，我参考了kern/mm/default_pmm.c 中 First Fit 算法的实现，只需要其中的修改 default_alloc_pages 函数，其他函数不变即可。
#### 2.2.2 修改代码部分
```
static struct Page *
best_fit_alloc_pages(size_t n) {
    assert(n > 0);
    if (n > nr_free) {
        return NULL;
    }
    struct Page *page = NULL;
    list_entry_t *le = &free_list;
    size_t min_size = nr_free + 1;
    /*LAB2 EXERCISE 2: YOUR CODE*/ 
    // 下面的代码是first-fit的部分代码，请修改下面的代码改为best-fit
    // 遍历空闲链表，查找满足需求的空闲页框
    // 如果找到满足需求的页面，记录该页面以及当前找到的最小连续空闲页框数量

   list_entry_t *best_le = NULL;  // 记录最佳位置的链表项
    
    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n && p->property < min_size) {
            // 找到更小的合适块，更新最小值和最佳位置
            min_size = p->property;
            best_le = le;
            page = p;
        }
    }

    // 如果找到了合适的页块
    if (page != NULL) {
        list_entry_t* prev = list_prev(&(page->page_link));
        list_del(&(page->page_link));  // 从链表中删除该页
        
        // 如果块比需要的大，分割块
        if (page->property > n) {
            struct Page *p = page + n;
            p->property = page->property - n;  // 设置剩余页的属性
            SetPageProperty(p);  // 标记为有属性
            
            // 将剩余部分重新插入到链表中
            list_add(prev, &(p->page_link));
        }
        
        nr_free -= n;  // 减少空闲页数量
        ClearPageProperty(page);  // 清除页属性标志（表示已分配）
    }
}

```
测试结果如下：
```
gong@gong-virtual-machine:~/operator_system/labcode/lab2$ make grade
>>>>>>>>>> here_make>>>>>>>>>>>
gmake[1]: 进入目录“/home/gong/operator_system/labcode/lab2” + cc kern/init/entry.S + cc kern/init/init.c + cc kern/libs/stdio.c + cc kern/debug/panic.c + cc kern/driver/console.c + cc kern/driver/dtb.c + cc kern/mm/best_fit_pmm.c + cc kern/mm/default_pmm.c + cc kern/mm/pmm.c + cc libs/printfmt.c + cc libs/readline.c + cc libs/sbi.c + cc libs/string.c + ld bin/kernel riscv64-unknown-elf-objcopy bin/kernel --strip-all -O binary bin/ucore.img gmake[1]: 离开目录“/home/gong/operator_system/labcode/lab2”
>>>>>>>>>> here_make>>>>>>>>>>>
<<<<<<<<<<<<<<< here_run_qemu <<<<<<<<<<<<<<<<<<
try to run qemu
qemu pid=6625
<<<<<<<<<<<<<<< here_run_check <<<<<<<<<<<<<<<<<<
  -check physical_memory_map_information:    OK
  -check_best_fit:                           OK
Total Score: 25/25
```
#### 2.2.3 改进空间
- 性能优化：每次分配都需要 O(n) 时间遍历整个链表，因此可以使用更高级的数据结构，例如平衡二叉树或跳表。
- 使用多个空闲链表：每个链表分别负责管理不同大小的空闲块，在分配时只要选择合适大小的链表再分配合适大小的空闲块。

# 3 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
## 3.1 练习一
First-Fit分配算法：
实验含义：通过链表遍历找到首个足够大的空闲块，实现分配/释放/合并。
原理对应：连续内存管理中的动态分区分配策略。
关系：实验是原理的具体代码实现，体现链表操作和碎片管理。
差异：实验是OS原理的具体代码实现。原理更侧重于算法思想：首次适应、最佳适应等和外部碎片等理论问题的分析；实验则聚焦于数据结构、边界条件处理等编码细节。
## 3.2 练习二
Best-Fit 算法算法：
实验含义：遍历空闲链表找到大小最接近请求大小的空闲块，实现精确匹配的内存分配，通过分割和合并操作管理内存碎片。
原理对应：连续内存管理中的最佳适应动态分区分配策略。
关系：实验是原理中Best-Fit算法的具体代码实现，体现了最小合适块搜索策略和碎片优化管理。
差异：原理更侧重于算法思想——Best-Fit通过选择最小合适块来减少浪费但可能产生小碎片；实验则聚焦于链表遍历、块分割时的边界处理、合并时的相邻块检测等具体编码细节。
## 4 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
虚拟内存和页替换算法，多级页表，TLB机制，交换和分页调度策略
