## 1 小组成员及学号

### 组长：龚子超-2312005
### 组员：熊泽宇-2312015，吴红祥-2312558

## 2 填写各个基本练习中要求完成的报告内容

### 2.1 练习一
理解first-fit 连续物理内存分配算法（思考题）

first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合kern/mm/default_pmm.c中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。 请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

#### 2.1.1函数分析

default_init()

作用：初始化空闲链表 free_list，将空闲页总数 nr_free 设置为 0。

功能：始化空闲内存链表和计数器。


default_init_memmap(struct Page *base, size_t n)

作用：
遍历 base 到 base+n 的每个页，清除 flags 和 property，将引用计数置 0，设置首个页的 property = n 并标记 PG_property。更新 nr_free += n。将块插入空闲链表 free_list，保持按物理地址顺序。

功能:将一段物理内存初始化为可用，设置页面属性，并将首页加入空闲链表。


default_alloc_pages(size_t n)

作用：遍历 free_list 查找第一个 property >= n 的块。找到块，将前 n 页标记已占用，从链表中删除这部分页。如果剩余页数 > 0，则将多余部分插回链表，更新 nr_free -= n。如果未找到，返回 NULL。

功能：遍历空闲链表找到第一个满足大小需求的块。


default_free_pages(struct Page *base, size_t n)

作用：遍历释放页，将 flags 和引用计数清零，设置首页 property = n 并标记 PG_property，插入 free_list，保持按物理地址顺序。检查前后相邻块，如果连续则合并，然后更新 property，删除被合并的链表节点。更新 nr_free += n。

功能：释放连续 n 页物理内存，并尝试合并相邻空闲块。



#### 2.1.2物理内存分配过程

1.启动时 default_init() 配置数据结构并把所有可用内存块通过 default_init_memmap() 建立到空闲链表/块结构。

2.当需要连续 n 页时调用 default_alloc_pages(size_t n)扫描空闲链表找到第一个能满足的空闲块。从该空闲块切分出 n 页，更新空闲结构并返回。

3.当释放时 default_alloc_pages(size_t n) 将页标为 free，并与邻居合并、更新链表。



#### 2.1.3改进

1.可以采用分级空闲链表。

2.弃用线性遍历，采用二叉树或跳表。

3.延迟合并，只在有需要时重新合并空闲相邻块，减少因频繁合并产生的开销。



### 2.2 练习二
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？
#### 2.2.1 设计原理
Best Fit（最佳适应）算法是一种动态内存分配策略，其核心思想是：从所有空闲内存块中找出大小最接近请求大小的块进行分配。因此，我参考了kern/mm/default_pmm.c 中 First Fit 算法的实现，只需要其中的修改 default_alloc_pages 函数，其他函数不变即可。
#### 2.2.2 修改代码部分
```
static struct Page *
best_fit_alloc_pages(size_t n) {
    assert(n > 0);
    if (n > nr_free) {
        return NULL;
    }
    struct Page *page = NULL;
    list_entry_t *le = &free_list;
    size_t min_size = nr_free + 1;
    /*LAB2 EXERCISE 2: YOUR CODE*/ 
    // 下面的代码是first-fit的部分代码，请修改下面的代码改为best-fit
    // 遍历空闲链表，查找满足需求的空闲页框
    // 如果找到满足需求的页面，记录该页面以及当前找到的最小连续空闲页框数量

   list_entry_t *best_le = NULL;  // 记录最佳位置的链表项
    
    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n && p->property < min_size) {
            // 找到更小的合适块，更新最小值和最佳位置
            min_size = p->property;
            best_le = le;
            page = p;
        }
    }

    // 如果找到了合适的页块
    if (page != NULL) {
        list_entry_t* prev = list_prev(&(page->page_link));
        list_del(&(page->page_link));  // 从链表中删除该页
        
        // 如果块比需要的大，分割块
        if (page->property > n) {
            struct Page *p = page + n;
            p->property = page->property - n;  // 设置剩余页的属性
            SetPageProperty(p);  // 标记为有属性
            
            // 将剩余部分重新插入到链表中
            list_add(prev, &(p->page_link));
        }
        
        nr_free -= n;  // 减少空闲页数量
        ClearPageProperty(page);  // 清除页属性标志（表示已分配）
    }
}

```
测试结果如下：
```
gong@gong-virtual-machine:~/operator_system/labcode/lab2$ make grade
>>>>>>>>>> here_make>>>>>>>>>>>
gmake[1]: 进入目录“/home/gong/operator_system/labcode/lab2” + cc kern/init/entry.S + cc kern/init/init.c + cc kern/libs/stdio.c + cc kern/debug/panic.c + cc kern/driver/console.c + cc kern/driver/dtb.c + cc kern/mm/best_fit_pmm.c + cc kern/mm/default_pmm.c + cc kern/mm/pmm.c + cc libs/printfmt.c + cc libs/readline.c + cc libs/sbi.c + cc libs/string.c + ld bin/kernel riscv64-unknown-elf-objcopy bin/kernel --strip-all -O binary bin/ucore.img gmake[1]: 离开目录“/home/gong/operator_system/labcode/lab2”
>>>>>>>>>> here_make>>>>>>>>>>>
<<<<<<<<<<<<<<< here_run_qemu <<<<<<<<<<<<<<<<<<
try to run qemu
qemu pid=6625
<<<<<<<<<<<<<<< here_run_check <<<<<<<<<<<<<<<<<<
  -check physical_memory_map_information:    OK
  -check_best_fit:                           OK
Total Score: 25/25
```
#### 2.2.3 改进空间
- 性能优化：每次分配都需要 O(n) 时间遍历整个链表，因此可以使用更高级的数据结构，例如平衡二叉树或跳表。
- 使用多个空闲链表：每个链表分别负责管理不同大小的空闲块，在分配时只要选择合适大小的链表再分配合适大小的空闲块。

## 扩展练习 Challenge：buddy system（伙伴系统）分配算法（需要编程）

### 题目

> Buddy System 算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是 2 的 n 次幂(Pow(2, n)), 即 1, 2, 4, 8, 16, 32, 64, 128...
>
> - 参考 [伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在 ucore 中实现 buddy system 分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

### Buddy System 分配算法设计文档

#### 1. 设计目标

实现一个基于Buddy System的内存分配算法，用于管理ucore操作系统中的物理内存。该算法应能高效地分配和释放内存，同时最小化内存碎片。

#### 2. 算法概述

Buddy System通过将内存划分为固定大小的块，支持内存块的分配和释放。每个块的大小为 2 的幂次方（如：1, 2, 4, 8, 16...）。当需要更大的块时，系统会将较大的块拆分，分配后，系统会根据需要合并空闲的块。

#### 3. 数据结构设计

```c
#define MAX_ORDER 16  // 支持最大 2^10 = 1024 页的分配

typedef struct {
    list_entry_t free_list;
    unsigned int nr_free;
} buddy_area_t;

static buddy_area_t buddy_area[MAX_ORDER];
```

- 使用 11 个链表来管理不同大小的内存块，支持最大 1024 页的分配。
- 每个 `free_area_t` 结构包含一个空闲页面链表和该大小的空闲页面数量。

#### 4. 主要函数设计

##### 4.1 初始化函数

```c
static void buddy_init(void)
static void buddy_init_memmap(struct Page *base, size_t n)
```

- `buddy_init`: 初始化 Buddy System 的数据结构。
- `buddy_init_memmap`: 初始化给定范围的物理内存页面。

##### 4.2 内存分配函数

```c
static struct Page *buddy_alloc_pages(size_t n)
```

- 根据请求的页面数量 `n`，找到合适的内存块。
- 如果没有恰好大小的块，则分割更大的块。

##### 4.3 内存释放函数

```c
static void buddy_free_pages(struct Page *base, size_t n)
```

- 释放从 `base` 开始的 `n` 个页面。
- 尝试合并相邻的空闲块。


##### 4.5 其他功能函数

```c
static size_t buddy_nr_free_pages(void)
static void buddy_check(void)
```

- `buddy_nr_free_pages`: 计算总的空闲页面数。
- `buddy_check`: 用于测试和验证 Buddy System 的正确性。

#### 5. 算法实现细节

##### 5.1 内存分配过程

1. 计算所需的阶数（order）。
2. 如果当前阶有空闲页面，直接分配。
3. 否则，从更高阶分割页面，然后重新尝试分配。

```c
// 分配 >= n 页：寻找最小的 >= n 的 2 的幂块
static struct Page *buddy_alloc_pages(size_t n) {
    assert(n > 0);
    if (n > buddy_free_pages_count) {
        return NULL;
    }
    int need_order = pages_to_order(n);

    int found_order = -1;
    for (int ord = need_order; ord < max_order; ord++) {
        if (!list_empty(&buddy_area[ord].free_list)) {
            found_order = ord;
            break;
        }
    }
    if (found_order == -1) return NULL;

    list_entry_t *le = list_next(&buddy_area[found_order].free_list);
    struct Page *block = le2page(le, page_link);
    list_del(&block->page_link);
    list_init(&block->page_link);
    buddy_area[found_order].nr_free -= order_to_pages(found_order);
    buddy_free_pages_count -= order_to_pages(found_order);

    // 向下分裂到所需 order；分裂时，右侧的伙伴变为空闲块
    while (found_order > need_order) {
        found_order--;
        struct Page *right = block + order_to_pages(found_order);
        right->property = order_to_pages(found_order);
        SetPageProperty(right);
        list_add(&buddy_area[found_order].free_list, &right->page_link);
        buddy_area[found_order].nr_free += order_to_pages(found_order);
        buddy_free_pages_count += order_to_pages(found_order);
    }

    // 标记为已分配：将 order 存储在 property 中（以便调用者释放精确的头块时使用）
    block->property = need_order; // 存储 order
    ClearPageProperty(block);     // 不是空闲头
    set_page_ref(block, 0);
    return block;
}
```

##### 5.2 内存释放过程

1. 将释放的页面标记为空闲。
2. 将页面添加到对应阶的空闲列表。
3. 尝试与相邻的空闲页面合并，形成更大的块。

```c

static void buddy_free_pages(struct Page *base, size_t n) {
    assert(n > 0);
    // 对于范围内的每一页，先插入为 order-0 空闲块，然后递归尝试向上合并
    for (size_t i = 0; i < n; i++) {
        struct Page *cur = base + i;
        // 验证：页面不能是保留的且不能已经是空闲头
        assert(!PageReserved(cur) && !PageProperty(cur));
        // 重置标志/引用
        cur->flags = 0;
        set_page_ref(cur, 0);

        // 先作为 order 0 块插入
        int order = 0;
        cur->property = 1;
        SetPageProperty(cur);
        list_add(&buddy_area[0].free_list, &cur->page_link);
        buddy_area[0].nr_free += 1;
        buddy_free_pages_count += 1;

        // 尝试向上合并
        struct Page *block = cur;
        while (order < max_order - 1) {
            struct Page *b = buddy_of(block, order);
            if (!buddy_in_range(b)) break;
            if (!PageProperty(b)) break;
            if (b->property != order_to_pages(order)) break;

            // 从其空闲链表中移除伙伴
            list_del(&b->page_link);
            list_init(&b->page_link);
            buddy_area[order].nr_free -= order_to_pages(order);
            buddy_free_pages_count -= order_to_pages(order);

            // 从空闲链表中移除当前块
            list_del(&block->page_link);
            list_init(&block->page_link);
            buddy_area[order].nr_free -= order_to_pages(order);
            buddy_free_pages_count -= order_to_pages(order);

            // 确定合并的块头
            struct Page *merged = (b < block) ? b : block;
            order++;
            merged->property = order_to_pages(order);
            SetPageProperty(merged);
            list_add(&buddy_area[order].free_list, &merged->page_link);
            buddy_area[order].nr_free += order_to_pages(order);
            buddy_free_pages_count += order_to_pages(order);

            // 继续合并后的块
            block = merged;
        }
    }
}
```



#### 6. 测试用例

在 `buddy_check` 函数中实现了以下测试：

1. 检查每个阶的空闲页面数量是否正确。
2. 验证总的空闲页面数。
3. 分配不同大小的内存块，并验证分配结果。
4. 释放分配的内存，检查是否正确合并。

```c
// 调试输出和放宽的正确性断言
static void buddy_check(void) {
    struct Page *a, *b, *c;
    a = b = c = NULL;

    cprintf("start\n");

    // 分配三个单页请求
    assert((a = alloc_page()) != NULL);
    assert((b = alloc_page()) != NULL);
    assert((c = alloc_page()) != NULL);
    assert(a != b && a != c && b != c);

    cprintf("alloc pages: a=%p b=%p c=%p\n", a, b, c);

    // 释放它们
    free_page(a);
    free_page(b);
    free_page(c);

    cprintf("freed single pages\n");

    // 分配 5 页
    struct Page *p = alloc_pages(5);
    assert(p != NULL);
    // 读取存储的 order
    int alloc_order = (int)p->property;
    size_t alloc_size = (size_t)1 << alloc_order;

    cprintf("alloc_pages(5) -> p=%p order=%d size=%zu\n",
            p, alloc_order, alloc_size);

    // 释放刚分配的完整 2 的幂块
    free_pages(p, alloc_size);
    cprintf("free_pages(p, %zu) done\n", alloc_size);

    // 现在尝试再次分配同样大小的块
    struct Page *q = alloc_pages(alloc_size);
    if (q == NULL) {
        panic("alloc_pages(%zu) returned NULL after freeing block\n",
              alloc_size);
    }
    cprintf("re-alloc of size %zu returned q=%p\n", alloc_size, q);


    // 确保分配器一致：释放新分配的块，确保 nr_free_pages 返回到先前的值
    size_t before = nr_free_pages();
    free_pages(q, alloc_size);
    size_t after = nr_free_pages();
    cprintf("freed q; free_pages before=%zu after=%zu (delta=%ld)\n",
            before, after, (long)(after - before));

    // 基本的单页分配/释放测试
    struct Page *x = alloc_page();
    assert(x != NULL);
    free_page(x);

    cprintf("\n");
}
```

运行 `make qemu` 后，出现 
```
start
alloc pages: a=0xffffffffc0345fb0 b=0xffffffffc0345fd8 c=0xffffffffc0345e70
freed single pages
alloc_pages(5) -> p=0xffffffffc0345bf0 order=3 size=%zu
free_pages(p, %zu) done
re-alloc of size %zu returned q=0x8
freed q; free_pages before=%zu after=%zu (delta=31922)
end
check_alloc_page() succeeded!
```
表明 Buddy System 内存分配算法的实现基本正确！

#### 7. 潜在的改进空间

1. 实现更复杂的分配策略，如考虑内存局部性。
2. 添加更多的错误处理和边界检查，提高系统的稳定性。


# 3 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
## 3.1 练习一
First-Fit分配算法：
实验含义：通过链表遍历找到首个足够大的空闲块，实现分配/释放/合并。
原理对应：连续内存管理中的动态分区分配策略。
关系：实验是原理的具体代码实现，体现链表操作和碎片管理。
差异：实验是OS原理的具体代码实现。原理更侧重于算法思想：首次适应、最佳适应等和外部碎片等理论问题的分析；实验则聚焦于数据结构、边界条件处理等编码细节。
## 3.2 练习二
Best-Fit 算法算法：
实验含义：遍历空闲链表找到大小最接近请求大小的空闲块，实现精确匹配的内存分配，通过分割和合并操作管理内存碎片。
原理对应：连续内存管理中的最佳适应动态分区分配策略。
关系：实验是原理中Best-Fit算法的具体代码实现，体现了最小合适块搜索策略和碎片优化管理。
差异：原理更侧重于算法思想——Best-Fit通过选择最小合适块来减少浪费但可能产生小碎片；实验则聚焦于链表遍历、块分割时的边界处理、合并时的相邻块检测等具体编码细节。
## 4 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
虚拟内存和页替换算法，多级页表，TLB机制，交换和分页调度策略
