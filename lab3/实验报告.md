## 1 小组成员及学号

### 组长：龚子超-2312005
### 组员：熊泽宇-2312015，吴红祥-2312558

## 2 填写各个基本练习中要求完成的报告内容

### 2.1 练习一：完善中断处理 （需要编程）
请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。

要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。


## 3 扩展练习 Challenge
### 3.1 Challenge1：描述与理解中断流程
扩展练习 Challenge1：描述与理解中断流程 回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

ucore中处理中断异常的流程：

1.CPU执行时发生中断/异常

2.保存PC到sepc，原因到scause，相关信息到stval，切换到S模式，跳转到stvec指向的__alltraps

3.__alltraps调用SAVE_ALL，在内核栈上保存所有寄存器和CSR到trapframe

4.根据 trapframe 中的 cause 字段判断是中断还是异常，并调用相应的处理函数，函数会执行具体任务处理具体中断异常

5.处理结束后，RESTORE_ALL恢复现场，回到被中断的程序继续执行原程序


mov a0, sp的目的：根据 RISC-V 的调用约定，a0 寄存器用于传递函数的第一个参数，因此，mov a0, sp 的目的是将这个 trapframe 的地址作为第一个参数，传递给接下来要调用的 C 函数 trap(struct trapframe *tf)。这使得 C 代码能够访问和操作被中断程序的所有保存状态


SAVE_ALL中寄存器保存在栈中的位置：SAVE_ALL 中寄存器的保存位置由 struct trapframe 的结构定义决定


__alltraps中是否需要保存所有寄存器： 是。因为C处理函数可能使用任何寄存器，如果不保存所有寄存器可能破坏原有程序，需保护现场；统一处理简化设计，为不同中断类型设计不同的保存恢复策略会使中断处理逻辑变得复杂且容易出错，支持上下文切换，在进行上下文切换时，内核需要完整保存当前进程的所有状态，并加载下一个进程的所有状态。。


### 3.2 Challenge2：理解上下文切换机制
回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？


csrw sscratch, sp：把当前 sp 保存到 sscratch 中

csrrw s0, sscratch, x0：把 sscratch 的值读出到 s0，同时把 x0 写回 sscratch
目的：触发异常时，将用户态的栈指针先保存到 sscratch；恢复时反过来，恢复用户态的栈指针


save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？


因为这些寄存器仅用于分析异常原因，不需要恢复，保存这些信息方便 trap 处理函数读取异常信息




### 3.3 Challenge3：完善异常中断





