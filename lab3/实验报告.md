## 1 小组成员及学号

### 组长：龚子超-2312005
### 组员：熊泽宇-2312015，吴红祥-2312558

## 2 填写各个基本练习中要求完成的报告内容

### 2.1 练习一：完善中断处理 （需要编程）
请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。

要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

#### 2.1.1 定时器中断中断处理的流程
整个时钟中断的处理过程可以分为硬件触发、陷入处理、以及中断响应三个阶段。
- 硬件触发阶段

RISC-V 定时器到期后触发 IRQ_S_TIMER；
CPU 进入内核态，保存寄存器到 trapframe；
跳转到异常入口 __alltraps。

- 陷入与分发阶段

__alltraps 保存上下文并调用 trap()；
trap() 通过 trap_dispatch() 判断类型；
若为中断，则进入 interrupt_handler()。

- 中断响应阶段

interrupt_handler() 识别为时钟中断；
调用 clock_set_next_event() 安排下次中断；
ticks++ 累加计数；
每 100 次打印 "100 ticks"；
打印 10 次后调用 sbi_shutdown() 关机；
恢复寄存器状态并返回。

#### 2.1.2 实现过程
本实验的目标是让操作系统能够在时钟中断触发时定期输出信息，并在触发 10 次打印后自动关机。核心逻辑位于 trap.c 文件的中断处理函数 interrupt_handler() 中。
- 代码修改位置

```
        /* LAB3 EXERCISE1   YOUR CODE :  */
            /*(1)设置下次时钟中断- clock_set_next_event()
             *(2)计数器（ticks）加一
             *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
            * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
            */
            // 安排下一次时钟中断 
            clock_set_next_event();

            static int printed_num = 0;

            // 递增 ticks 并检查是否达到阈值
            ticks++;
            if (ticks % TICK_NUM == 0) {
                // 每 100 次 ticks 打印一次 
                print_ticks();
                printed_num++;

                // 打印达到 10 次时关机 
                if (printed_num % 10 == 0) {
                    // 调用 SBI 提供的关机函数
                    sbi_shutdown();
                   
                }
            }
            break;
```
- 主要逻辑说明

设置下次时钟中断:
通过 clock_set_next_event() 通知定时器硬件下一次中断的触发时刻，保证系统时钟能周期性触发中断;

累积中断次数:
使用全局变量 ticks 记录时钟中断累计次数，每次中断 ticks++;

定期打印:
当 ticks 达到 100 的倍数时，调用 print_ticks() 输出 "100 ticks";

控制打印次数:
用局部静态变量 printed_num 记录打印了多少次 "100 ticks"；当打印次数达到 10 次后，调用 sbi_shutdown() 使系统正常关机。

- 实验效果
```
gong@gong-virtual-machine:~/operator_system/labcode/lab3$ make qemu
+ cc kern/trap/trap.c
+ cc kern/trap/trapentry.S
+ cc kern/mm/best_fit_pmm.c
+ cc kern/mm/default_pmm.c
+ cc kern/mm/pmm.c
+ cc libs/printfmt.c
+ cc libs/readline.c
+ cc libs/sbi.c
+ cc libs/string.c
+ ld bin/kernel
riscv64-unknown-elf-objcopy bin/kernel --strip-all -O binary bin/ucore.img

OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
DTB Init
HartID: 0
DTB Address: 0x82200000
Physical Memory from DTB:
  Base: 0x0000000080000000
  Size: 0x0000000008000000 (128 MB)
  End:  0x0000000087ffffff
DTB init completed
(THU.CST) os is loading ...
Special kernel symbols:
  entry  0xffffffffc0200054 (virtual)
  etext  0xffffffffc0201f24 (virtual)
  edata  0xffffffffc0206028 (virtual)
  end    0xffffffffc02064a0 (virtual)
Kernel executable memory footprint: 26KB
memory management: default_pmm_manager
physcial memory map:
  memory: 0x0000000008000000, [0x0000000080000000, 0x0000000087ffffff].
check_alloc_page() succeeded!
satp virtual address: 0xffffffffc0205000
satp physical address: 0x0000000080205000
++ setup timer interrupts
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
gong@gong-virtual-machine:~/operator_system/labcode/lab3$ 
```
## 3 扩展练习 Challenge
### 3.1 Challenge1：描述与理解中断流程
扩展练习 Challenge1：描述与理解中断流程 回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

ucore中处理中断异常的流程：

1.CPU执行时发生中断/异常

2.保存PC到sepc，原因到scause，相关信息到stval，切换到S模式，跳转到stvec指向的__alltraps

3.__alltraps调用SAVE_ALL，在内核栈上保存所有寄存器和CSR到trapframe

4.根据 trapframe 中的 cause 字段判断是中断还是异常，并调用相应的处理函数，函数会执行具体任务处理具体中断异常

5.处理结束后，RESTORE_ALL恢复现场，回到被中断的程序继续执行原程序


mov a0, sp的目的：根据 RISC-V 的调用约定，a0 寄存器用于传递函数的第一个参数，因此，mov a0, sp 的目的是将这个 trapframe 的地址作为第一个参数，传递给接下来要调用的 C 函数 trap(struct trapframe *tf)。这使得 C 代码能够访问和操作被中断程序的所有保存状态


SAVE_ALL中寄存器保存在栈中的位置：SAVE_ALL 中寄存器的保存位置由 struct trapframe 的结构定义决定


__alltraps中是否需要保存所有寄存器： 是。因为C处理函数可能使用任何寄存器，如果不保存所有寄存器可能破坏原有程序，需保护现场；统一处理简化设计，为不同中断类型设计不同的保存恢复策略会使中断处理逻辑变得复杂且容易出错，支持上下文切换，在进行上下文切换时，内核需要完整保存当前进程的所有状态，并加载下一个进程的所有状态。。


### 3.2 Challenge2：理解上下文切换机制
回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？


csrw sscratch, sp：把当前 sp 保存到 sscratch 中

csrrw s0, sscratch, x0：把 sscratch 的值读出到 s0，同时把 x0 写回 sscratch
目的：触发异常时，将用户态的栈指针先保存到 sscratch；恢复时反过来，恢复用户态的栈指针


save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？


因为这些寄存器仅用于分析异常原因，不需要恢复，保存这些信息方便 trap 处理函数读取异常信息




### 3.3 Challenge3：完善异常中断





