## 1 小组成员及学号

### 组长：龚子超-2312005
### 组员：熊泽宇-2312015，吴红祥-2312558

## 2 填写各个基本练习中要求完成的报告内容

### 2.1 练习一：加载应用程序并执行（需要编码）
do_execve函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

请在实验报告中简要说明你的设计实现过程。

请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

#### 2.1.1 设计实现过程


### 2.2 练习二：父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。

如何设计实现Copy on Write机制？给出概要设计，鼓励给出详细设计。

#### 2.2.1 设计实现过程
copy_range 的设计目标是在进程创建（fork）过程中，将父进程用户态虚拟地址空间中指定区间 [start, end) 的有效内存页完整复制到子进程中，使子进程获得一份与父进程相互独立的地址空间副本。 

1. 按页遍历用户虚拟地址空间 

函数首先对 start 和 end 做页对齐与用户态地址合法性检查，然后以 页（PGSIZE）为基本单位，从 start 到 end 逐页遍历父进程的用户虚拟地址空间，确保内存复制的粒度与页表管理方式一致。 

2. 查找父进程页表项 

在遍历过程中，通过 get_pte(from, start, 0) 查找父进程在当前虚拟地址处的页表项： 

- 若页表项不存在，说明该地址范围内没有映射页面，直接跳过该页表对应的地址区间； 

- 若页表项存在且有效（PTE_V），则说明父进程在该虚拟地址处映射了物理页，需要进行复制。 

3. 为子进程分配页表项和物理页 

对于父进程中存在的有效页面： 

- 使用 get_pte(to, start, 1) 在子进程页表中创建或获取对应的页表项； 

- 调用 alloc_page() 为子进程分配一个新的物理页，用于存放复制后的页面内容； 

- 从父进程页表项中提取用户态访问权限，并用于子进程页面映射。 

4. 复制页面内容 
利用 page2kva 将父进程物理页和子进程新分配的物理页分别转换为内核虚拟地址，然后使用 memcpy 将父进程物理页中的全部内容（一个页面大小）复制到子进程的新物理页中，从而保证父子进程页面内容一致但物理上相互独立。 

5. 建立子进程页表映射 

在页面内容复制完成后，通过 page_insert 将子进程的新物理页映射到对应的用户虚拟地址，并设置与父进程一致的访问权限。这样，子进程在该虚拟地址处即可正确访问复制后的内存页。 

#### 2.2.2 如何设计实现 Copy-on-Write（COW）机制？

Copy-on-Write（COW）的核心思想是在进程创建时不立即复制物理内存页面，而是在写操作发生时才进行复制，从而减少不必要的内存拷贝，提高 fork 的性能和内存利用率。 

1. fork 阶段的页面共享策略： 

在 fork 阶段，父子进程不再为每个页面分配新的物理页，而是让父子进程的页表项同时指向同一个物理页，并将这些页表项的写权限（PTE_W）清除，同时设置一个表示 COW 的标志位（如 PTE_COW）。此时，物理页的引用计数增加，表示该页被多个进程共享。 

2. 写异常触发与 COW 处理流程： 

当父进程或子进程对某个共享页面进行写操作时，由于页表项不具有写权限，会触发一次写异常（Page Fault）。在缺页异常处理函数中，操作系统检测到该页表项被标记为 COW，于是为当前进程分配一个新的物理页，将原物理页的内容复制到新页中，然后更新当前进程的页表项，使其指向新分配的物理页，并恢复写权限，同时清除 COW 标志。原物理页的引用计数相应减少。 

3. 引用计数优化与特殊情况处理： 

如果在写异常发生时发现该物理页的引用计数为 1，说明该页面并未被其他进程共享，则无需进行复制，只需直接恢复写权限即可。 

4. 总结： 

通过上述机制，COW 实现了“读时共享、写时复制”，在保证进程地址空间隔离性的同时，大幅降低了 fork 操作的时间和空间开销，是现代操作系统中 fork 实现的常用优化方法。

### 练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：

请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？
请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）
执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。（使用的是qemu-4.1.1）

#### 2.3.1 实现过程

## 3 分支任务

### 3.1 LAB2分支任务：gdb 调试页表查询过程

### 3.2 LAB5分支任务：gdb 调试系统调用以及返回



