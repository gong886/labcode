## 1 小组成员及学号

### 组长：龚子超-2312005
### 组员：熊泽宇-2312015，吴红祥-2312558

## 2 填写各个基本练习中要求完成的报告内容

### 2.1 练习一：分配并初始化一个进程控制块（需要编码）
alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

#### 2.1.1 设计实现过程

- 1.使用 `kmalloc` 为 `proc_struct` 分配内存。
- 2.字段初始化：`pgdir` 设置为 `boot_pgdir_pa`，表示进程的页目录表地址。`state` 设置为 `PROC_UNINIT`，表示进程初始状态为未初始化。`pid` 设置为 `-1`，表示进程 ID 尚未分配。`context` 和 `name` 使用 `memset` 清零，确保上下文和名称字段的初始值正确。
- 3.返回初始化后的 `proc_struct` 指针。


以下是实现的 `alloc_proc` 函数的核心代码：
```c
struct proc_struct *alloc_proc(void) {
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL) {
        proc->pgdir = boot_pgdir_pa; // 页目录表地址
        proc->state = PROC_UNINIT; // 进程状态：未初始化
        proc->pid = -1; // 进程 ID
        proc->runs = 0;  // 运行次数
        proc->kstack = 0; // 内核栈地址
        proc->need_resched = 0; // 调度标志
        proc->flags = 0; // 进程标志
        proc->parent = NULL; // 父进程指针
        proc->mm = NULL; // 内存管理结构
        proc->tf = NULL; // 中断帧指针
        memset(&(proc->context), 0, sizeof(struct context)); // 清空上下文
        memset(proc->name, 0, PROC_NAME_LEN + 1);    // 清空进程名称        
    }
    return proc;
}
```

#### 2.1.2 `proc_struct` 中的关键字段含义及作用
-`struct context context`:
  - 含义：保存进程的上下文信息，包括寄存器值等，用于进程切换时保存和恢复 CPU 的状态。
  - 作用：在进程切换时，当前进程的上下文会被保存到 `context` 中，切换到其他进程时会从其 `context` 中恢复上下文。
  - 实验中的作用：在 `proc_run` 函数中，通过调用 `switch_to` 函数切换进程时，`context` 用于保存和恢复进程的运行状态。

-`struct trapframe *tf`：
  - 含义：保存进程在发生中断或异常时的寄存器状态。
  - 作用：在中断或异常发生时，`trapframe` 用于保存当前进程的寄存器状态，以便中断处理完成后恢复。
  - 实验中的作用：在 `do_fork` 函数中，`tf` 被复制到子进程，用于初始化子进程的中断上下文。在 copy_thread 中，`tf` 被复制到子进程。在 forkret 中，`tf` 被用于恢复用户态

### 2.1.3 结果
```c
gmake[1]: Entering directory '/home/wsl2312558/code/os/lab4' + cc kern/init/entry.S + cc kern/init/init.c + cc kern/libs/readline.c + cc kern/libs/stdio.c + cc kern/debug/kdebug.c + cc kern/debug/kmonitor.c + cc kern/debug/panic.c + cc kern/driver/clock.c + cc kern/driver/console.c + cc kern/driver/dtb.c + cc kern/driver/intr.c + cc kern/driver/picirq.c + cc kern/trap/trap.c + cc kern/trap/trapentry.S + cc kern/mm/default_pmm.c + cc kern/mm/kmalloc.c + cc kern/mm/pmm.c + cc kern/mm/vmm.c + cc kern/process/entry.S + cc kern/process/proc.c + cc kern/process/switch.S + cc kern/schedule/sched.c + cc libs/hash.c + cc libs/printfmt.c + cc libs/string.c + ld bin/kernel riscv64-unknown-elf-objcopy bin/kernel --strip-all -O binary bin/ucore.img gmake[1]: Leaving directory '/home/wsl2312558/code/os/lab4'
  -check alloc proc:                         OK
  -check initproc:                           WRONG
   -e !! error: missing 'this initproc, pid = 1, name = "init"'
   !! error: missing 'To U: "Hello world!!".'
   !! error: missing 'To U: "en.., Bye, Bye. :)"'

Total Score: 15/30
make: *** [Makefile:207: grade] Error 1
```
### 2.2 练习二：为新创建的内核线程分配资源（需要编码）
创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们实际需要"fork"的东西就是stack和trapframe。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：

- 调用alloc_proc，首先获得一块用户信息块。
- 为进程分配一个内核栈。
- 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
- 复制原进程上下文到新进程
- 将新进程添加到进程列表
- 唤醒新进程
- 返回新进程号
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。
#### 2.2.1 设计实现过程

### 练习3：编写proc_run 函数（需要编码）
proc_run用于将指定的进程切换到CPU上运行。它的大致执行步骤包括：
- 检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
- 禁用中断。你可以使用 /kern/sync/sync.h 中定义好的宏 local_intr_save(x) 和 local_intr_restore(x) 来实现关、开中断。
- 切换当前进程为要运行的进程。
- 切换页表，以便使用新进程的地址空间。 /libs/riscv.h 中提供了 lsatp(unsigned int pgdir) 函数，可实现修改SATP寄存器值的功能。
- 实现上下文切换。 /kern/process 中已经预先编写好了 switch.S ，其中定义了 switch_to() 函数。可实现两个进程的context切换。
- 允许中断。
- 请回答如下问题：在本实验的执行过程中，创建且运行了几个内核线程？

#### 2.3.1 实现过程

以下是实现的 `proc_run` 函数的核心代码：
```c
void proc_run(struct proc_struct *proc)
{
    if (proc != current)
    {   
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;

        //禁用中断
        local_intr_save(intr_flag);
        {
            current = proc;
            lsatp(proc->pgdir);//切换页表
            switch_to(&(prev->context), &(next->context));//进行上下文切换,之后代码执行流会跳转到next进程上次停止的地方或新进程的入口
        }
        local_intr_restore(intr_flag);//恢复中断状态
    }
}
```

#### 2.3.2 在本实验的执行过程中，创建且运行了几个内核线程

-通过分析 proc_init 函数的代码逻辑，可以看到先后创建了两个内核线程：
  - 1. idleproc (第 0 号线程)
    - 创建：在代码中调用 idleproc = alloc_proc() 创建。
    - 初始化：它被初始化为 PID = 0，名字为 "idle"。
    - 运行：在current = idleproc; 将其设置为当前运行进程。随后在内核初始化完成后，它会执行 cpu_idle() 函数，在这个死循环中不断查询是否需要调度。
    - 作用：它是系统的空闲线程，当没有其他就绪进程时，CPU 就运行它。
  - 2. initproc (第 1 号线程)
    - 创建：在代码中调用 kernel_thread(init_main, "Hello world!!", 0); 创建。kernel_thread 内部会调用 do_fork 来创建一个新的线程。
    - 初始化：它被初始化为 PID = 1，名字为 "init"。它的入口函数是 init_main。
    - 运行：虽然它是由 idleproc 创建的，但它创建后状态变为 PROC_RUNNABLE。当 idleproc 运行 schedule() 时，调度器会切换到 initproc 执行，从而打印出 "Hello world!!" 等信息。
    - 作用：它是本实验中的第一个“实际工作”线程，用于演示线程的创建和输出。

### 2.3.3 结果
- make qemu
```c
Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
DTB Init
HartID: 0
DTB Address: 0x82200000
Physical Memory from DTB:
  Base: 0x0000000080000000
  Size: 0x0000000008000000 (128 MB)
  End:  0x0000000087ffffff
DTB init completed
(THU.CST) os is loading ...

Special kernel symbols:
  entry  0xc020004a (virtual)
  etext  0xc0203e98 (virtual)
  edata  0xc0209030 (virtual)
  end    0xc020d4ec (virtual)
Kernel executable memory footprint: 54KB
memory management: default_pmm_manager
physcial memory map:
  memory: 0x08000000, [0x80000000, 0x87ffffff].
vapaofset is 18446744070488326144
check_alloc_page() succeeded!
check_pgdir() succeeded!
check_boot_pgdir() succeeded!
use SLOB allocator
kmalloc_init() succeeded!
check_vma_struct() succeeded!
check_vmm() succeeded.
alloc_proc() correct!
++ setup timer interrupts
this initproc, pid = 1, name = "init"
To U: "Hello world!!".
To U: "en.., Bye, Bye. :)"
kernel panic at kern/process/proc.c:406:
    process exit!!.

Welcome to the kernel debug monitor!!
Type 'help' for a list of commands.
```
-make grade
```c
gmake[1]: Entering directory '/home/xiongxiongxiong/os/labcode/lab4' + cc kern/init/entry.S + cc kern/init/init.c + cc kern/libs/readline.c + cc kern/libs/stdio.c + cc kern/debug/kdebug.c + cc kern/debug/kmonitor.c + cc kern/debug/panic.c + cc kern/driver/clock.c + cc kern/driver/console.c + cc kern/driver/dtb.c + cc kern/driver/intr.c + cc kern/driver/picirq.c + cc kern/trap/trap.c + cc kern/trap/trapentry.S + cc kern/mm/default_pmm.c + cc kern/mm/kmalloc.c + cc kern/mm/pmm.c + cc kern/mm/vmm.c + cc kern/process/entry.S + cc kern/process/proc.c + cc kern/process/switch.S + cc kern/schedule/sched.c + cc libs/hash.c + cc libs/printfmt.c + cc libs/string.c + ld bin/kernel riscv64-unknown-elf-objcopy bin/kernel --strip-all -O binary bin/ucore.img gmake[1]: Leaving directory '/home/xiongxiongxiong/os/labcode/lab4'
  -check alloc proc:                         OK
  -check initproc:                           OK
Total Score: 30/30
```

## 3 扩展练习 Challenge





